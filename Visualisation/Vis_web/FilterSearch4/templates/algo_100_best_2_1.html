<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>InSoLiTo graph</title>

    <!--   Autocomplete flask   -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.css" rel="stylesheet" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

    <!--  Neo4j  -->
    <script type="text/javascript" src="{{url_for('static',filename='js/neovis.js')}}"></script>


    <style type="text/css">
        html,
        body {
            height: 100%;
            margin: 0px
        }

        .visualization {

            width: 80%;
            height: 100%;
            /*border: 1px solid white;*/
            font: 22pt arial;
            background: white;
            z-index: 10;

        }
        #viz {
            width: 80%;
            height: 100%;
            position:absolute;
        }
        .loadingbar {
            width: 80%;
            height: 100%;
            z-index: 9;
            background: #009938;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 100%;
            position:absolute;
        }

        #mydiv {
            right: 0;
            top: 0;
            bottom: 0;
            width: 20%;
            height: 100%;
            background: #404040;
            padding: 1em;
            color: white;

            position: absolute;
            box-sizing: border-box;
            transition-property: opacity;
            transition-duration: 250ms;
            transition-timing-function: ease-out;
            overflow: auto;
            z-index: 1;
        }

        .column {
            padding: 5px;
        }

        .rangesli {
            margin: auto;
            width: 20rem;

        }

        div.ui-slider-range.ui-widget-header {
            background: #2196F3;
        }

        .rangeyears {
            border: 0;
            background: #f1f1f1;
            margin: auto;
            color: #2196F3;
            text-align: center;
            font-weight: bold;
            padding-top: 5px;
        }

        .vis-button vis-up {
            background-image: "../static/database_centered.png";
        }

        div.vis-network div.vis-navigation div.vis-button.vis-up {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' class='vis-icon vis-icon--up' width='30' height='30' viewBox='0 0 24 24' fill='none' stroke='%23808080' stroke-width='2' stroke-linecap='square' stroke-linejoin='arcs'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M16 12l-4-4-4 4M12 16V9'/%3E%3C/svg%3E");
            bottom: 50px;
            left: 55px;
        }

        div.vis-network div.vis-navigation div.vis-button.vis-down {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' class='vis-icon vis-icon--down' width='30' height='30' viewBox='0 0 24 24' fill='none' stroke='%23808080' stroke-width='2' stroke-linecap='square' stroke-linejoin='arcs'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M16 12l-4 4-4-4M12 8v7'/%3E%3C/svg%3E");
            bottom: 10px;
            left: 55px;
        }

        div.vis-network div.vis-navigation div.vis-button.vis-left {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' class='vis-icon vis-icon--left' width='30' height='30' viewBox='0 0 24 24' fill='none' stroke='%23808080' stroke-width='2' stroke-linecap='square' stroke-linejoin='arcs'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 8l-4 4 4 4M16 12H9'/%3E%3C/svg%3E");
            bottom: 10px;
            left: 15px;
        }

        div.vis-network div.vis-navigation div.vis-button.vis-right {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' class='vis-icon vis-icon--right' width='30' height='30' viewBox='0 0 24 24' fill='none' stroke='%23808080' stroke-width='2' stroke-linecap='square' stroke-linejoin='arcs'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 8l4 4-4 4M8 12h7'/%3E%3C/svg%3E");
            bottom: 10px;
            left: 95px;
        }

        div.vis-network div.vis-navigation div.vis-button.vis-zoomExtends {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' class='vis-icon vis-icon--zoom-extends' width='30' height='30' viewBox='0 0 24 24' fill='none' stroke='%23808080' stroke-width='2' stroke-linecap='square' stroke-linejoin='arcs'%3E%3Cpath d='M7.027 7.027l9.946 9.946m0-9.946l-9.946 9.946m6.792-10.43h3.64v3.64m-7.278-3.64h-3.64v3.64m7.278 7.278h3.64v-3.64m-7.278 3.64h-3.64v-3.64' stroke-width='1.6'/%3E%3Ccircle cx='12.102' cy='12.102' r='10'/%3E%3C/svg%3E");
            bottom: 50px;
            right: 15px;
        }

        div.vis-network div.vis-navigation div.vis-button.vis-zoomIn {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' class='vis-icon vis-icon--zoomIn' width='30' height='30' viewBox='0 0 24 24' fill='none' stroke='%23808080' stroke-width='2' stroke-linecap='square' stroke-linejoin='arcs'%3E%3Ccircle cx='12.102' cy='12.102' r='10'%3E%3C/circle%3E%3Cline x1='12' y1='8' x2='12' y2='16'%3E%3C/line%3E%3Cline x1='8' y1='12' x2='16' y2='12'%3E%3C/line%3E%3C/svg%3E");
            bottom: 10px;
            right: 15px;
        }

        div.vis-network div.vis-navigation div.vis-button.vis-zoomOut {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' class='vis-icon vis-icon--zoomOut' width='30' height='30' viewBox='0 0 24 24' fill='none' stroke='%23808080' stroke-width='2' stroke-linecap='square' stroke-linejoin='arcs'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cline x1='8' y1='12' x2='16' y2='12'%3E%3C/line%3E%3C/svg%3E");
            bottom: 10px;
            right: 55px;
        }


        #context-menu {
            position: fixed;
            z-index: 10000;
            width: 150px;
            background: #1b1a1a;
            transform: scale(0);
            transform-origin: top left;
        }

        #context-menu.visible {
            transform: scale(1);
            transition: transform 200ms ease-in-out;
        }

        #context-menu .item button {
            width: 150px;
            background: #1b1a1a;
            border-radius: 5px;
            padding: 8px 10px;
            font-size: 15px;
            color: #eee;
            cursor: pointer;
            border-radius: inherit;
            border-width: 0px;
        }

        #context-menu .item button:hover {
            background: #343434;
        }

        #context-menu .topicmenu button {
            background: #97c2fc;
            transition: 0.3s;
            border: none;
            /*             padding:20; */
            border-radius: 6px;
            text-align: center;
            display: block;
            margin-left: auto;
            margin-right: auto;
            margin-top: 3px;
            margin-bottom: 3px;
            padding: 2px 2px;
            font-size: 11px;
            color: black;
            cursor: pointer;

        }

        #context-menu .topicmenu button:hover {
            background: #FCD197;
        }

        .ui-menu img {
            width: 40px;
            height: 40px;
        }

        .ui-menu li span {
            font-size: 2em;
            padding: 0 0 10px 10px;
            margin: 0 0 10px 0 !important;
            white-space: nowrap;
        }
    </style>

    <script type="text/javascript">
        var viz;
        function draw() {
            var config = {
                container_id: "viz",
                neo4j: {
                    server_url: "bolt://localhost:7687",
                    server_user: "neo4j",
                    server_password: ""
                },
                visConfig: {
                    layout: {
                        randomSeed: 34
                    },
                    physics: {
                        forceAtlas2Based: {
                            gravitationalConstant: -200,
                            //                             centralGravity: 0.005,
                            springLength: 400,
                            springConstant: 0.36,
                            avoidOverlap: 1
                        },
                        maxVelocity: 30,
                        solver: "forceAtlas2Based",
                        timestep: 1,
                        stabilization: {
                            enabled: true,
                            iterations: 2000,
                            updateInterval: 25,
                            fit:true
                        },

                    },
                    interaction: {
                        tooltipDelay: 200,
                        navigationButtons: true,
                        keyboard: true
                    },
                    nodes: {
                        shapeProperties: {
                            interpolation: false    // 'true' for intensive zooming
                        }
                    },
                    layout: {
                        improvedLayout: false
                    }
                },
                labels: {
                    Publication: {
                        label: "subtitle",
                        group: "community",
                        [NeoVis.NEOVIS_ADVANCED_CONFIG]: {
                            static: {
                                image: "{{url_for('static', filename='paper_centered_sm.png')}}",
                                shape: "circularImage"
                                //                                 color: "#97c2fc",
                            },
                            function: {
                                title: (props) => NeoVis.objectToTitleHtml(props, ["title", "year"])
                            }
                        },
                    },
                    InferedTool: {
                        label: "name",
                        group: "community",
                        [NeoVis.NEOVIS_ADVANCED_CONFIG]: {
                            static: {
                                image: "{{url_for('static', filename='tool_centered_sm.png')}}",
                                shape: "circularImage"
                            }
                        }
                    },
                    Database: {
                        label: "name",
                        //value: "pageRank",
                        group: "community",
                        [NeoVis.NEOVIS_ADVANCED_CONFIG]: {
                            static: {
                                image: "{{url_for('static', filename='database_centered_sm.png')}}",
                                shape: "circularImage"
                            }
                        }
                    }
                },
                relationships: {
                    //                     METAOCCUR: {
                    //                         value: "times",
                    //                         title: "year"
                    //                     },
                    METAOCCUR_ALL: {
                        value: "times"
                    }
                },
                arrows: false,
            };
            viz = new NeoVis.default(config);
            viz.render();

        }
    </script>
</head>

<body onload="draw()">

    <div id="mydiv">
        <div id="reset">Reset </div>
        <div id="stabilize">Stabilize</div>


        <div id="tools-list">
            <ul>
            </ul>
        </div>
        <div class="column">
            <input type="text" id="tooltopic_autocomplete">

        </div>
        <div class="column">
            <p>Number of occurrences between tools:</p>
            <canvas id="myCanvas" width="300" height="100"></canvas>
            <div id="slider-range" class="rangesli"></div>
            <input type="text" id="amount" readonly class="rangeyears">
        </div>

        <div class="column">
            <p>Color nodes:</p>
            <form name="ClusterForm">
                <input type="radio" id="cluster" name="cluster_mode" value="Cluster" onchange="ClusterMode()" checked>
                <label for="cluster">Cluster mode</label><br>
                <input type="radio" id="normal" name="cluster_mode" value="Normal" onchange="ClusterMode()">
                <label for="normal">Normal mode</label><br>
            </form>
        </div>
    </div>
    <div class="visualization">
        <div id="viz" ></div>


        <div id="context-menu"></div>
        
        <div id="loading"></div>
    </div>
    

</body>

<script>

    var myCanvas = document.getElementById("myCanvas");
    // myCanvas.width = 500;
    // myCanvas.height = 300;

    var ctx = myCanvas.getContext("2d");

    function drawLine(ctx, startX, startY, endX, endY, color) {
        ctx.save();
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.restore();
    }

    function drawBar(ctx, upperLeftCornerX, upperLeftCornerY, width, height, color) {
        ctx.save();
        ctx.fillStyle = color;
        ctx.fillRect(upperLeftCornerX, upperLeftCornerY, width, height);
        ctx.restore();
    }

    var Barchart = function (options) {
        this.options = options;
        this.canvas = options.canvas;
        this.ctx = this.canvas.getContext("2d");
        this.colors = options.colors;

        this.draw = function () {
            var maxValue = 0;
            for (var categ in this.options.data) {
                maxValue = Math.max(maxValue, this.options.data[categ]);
            }
            var canvasActualHeight = this.canvas.height - this.options.padding * 2;
            var canvasActualWidth = this.canvas.width - this.options.padding * 2;

            //drawing the grid lines
            var gridValue = 0;
            while (gridValue <= maxValue) {
                var gridY = canvasActualHeight * (1 - gridValue / maxValue) + this.options.padding;
                drawLine(
                    this.ctx,
                    0,
                    gridY,
                    this.canvas.width,
                    gridY,
                    this.options.gridColor
                );

                //writing grid markers
                this.ctx.save();
                this.ctx.fillStyle = this.options.gridColor;
                //             this.ctx.font = "bold 10px Arial";
                //             this.ctx.fillText(gridValue, 10,gridY - 2);
                this.ctx.restore();

                gridValue += this.options.gridScale;
            }

            //drawing the bars
            var barIndex = 0;
            var numberOfBars = Object.keys(this.options.data).length;
            var barSize = (canvasActualWidth) / numberOfBars;

            for (categ in this.options.data) {
                var val = this.options.data[categ];
                var barHeight = Math.round(canvasActualHeight * val / maxValue);
                drawBar(
                    this.ctx,
                    this.options.padding + barIndex * barSize,
                    this.canvas.height - barHeight - this.options.padding,
                    barSize,
                    barHeight,
                    this.colors[barIndex % this.colors.length]
                );

                barIndex++;
            }
        }
    }

    var OccurData = '{{relations|safe}}';
    OccurData = JSON.parse(OccurData);
    console.log(OccurData);

    var myBarchart = new Barchart(
        {
            canvas: myCanvas,
            padding: 0,
            data: OccurData,
            colors: ["#36aaf7"]
        }
    );
    myBarchart.draw();

</script>

<script>

    function logslider(position) {
        // position will be between 0 and 100
        var minp = 0;
        var maxp = 100;

        // The result should be between 100 an 10000000
        var minv = Math.log(parseInt(Object.keys(OccurData)[0]));
        var maxv = Math.log(parseInt(Object.keys(OccurData)[Object.keys(OccurData).length - 1]));

        // calculate adjustment factor
        var scale = (maxv - minv) / (maxp - minp);

        return Math.trunc(Math.exp(minv + scale * (position - minp)));
    }

    $(function () {
        $("#slider-range").slider({
            range: true,
            min: 0,
            max: 100,
            values: [0, 100],
            slide: function (event, ui) {
                $("#amount").val(logslider(ui.values[0]) + " - " + logslider(ui.values[1]));
            }
        });
        $("#amount").val(logslider($("#slider-range").slider("values", 0)) +
            " - " + logslider($("#slider-range").slider("values", 1)));
    });

</script>

<script>

    async function AddTool(NameTool, c_min, c_max) {

        var cypher_query = 'MATCH (i)-[o:METAOCCUR_ALL]-(p) where i.name="' + NameTool + '" and o.times>' + c_min + ' and o.times<' + c_max + ' return i,o,p order by o.times';

        viz.updateWithCypher(cypher_query);

        const list = document.querySelector('#loading');
        const Loadingtext = document.createElement('span');
        Loadingtext.textContent = "Loading...";
        Loadingtext.classList.add('loadingbar');
        list.appendChild(Loadingtext);


        console.log(cypher_query);
        await new Promise(r => setTimeout(r, 500));
        console.log(viz.nodes.length);
        if (viz.nodes.length == 0) {
            alert("No results found. Try again!");
        }
        algo(c_min, c_max);
        await new Promise(r => {
            StoreClusterColor();
            WaitAddTool();

        });



    };

    function AddLabelMenu(name, id) {
        const list = document.querySelector('#tools-list ul');

        // create elements
        const value = name
        const li = document.createElement('li');
        const ToolName = document.createElement('span');
        //   const deleteBtn = document.createElement('span');

        // add text content
        ToolName.textContent = value;
        //   deleteBtn.textContent = 'delete';
        // add classes
        ToolName.classList.add('delete');
        ToolName.value = id;

        // append to DOM
        li.appendChild(ToolName);
        //   li.appendChild(deleteBtn);
        list.appendChild(li);
        //list.insertBefore(li, list.querySelector('li:first-child'));

        // delete books
        list.addEventListener('click', (e) => {
            if (e.target.className == 'delete') {
                const li = e.target.parentElement;
                li.parentNode.removeChild(li);
                var IdTool = e.target.value;
                console.log(IdTool);
                if (Array.isArray(IdTool)) {

                    IdTool.forEach((tool) => {
                        console.log(tool);
                        if (viz.nodes.get(tool) != null) {
                            viz.network.unselectAll();
                            var ConnectedNodes = viz.network.getConnectedNodes(tool);

                            var UnconnectedNodes = [];
                            ConnectedNodes.forEach((node) => {
                                //                             if(viz.network.getConnectedEdges(node).length==1){
                                UnconnectedNodes.push(node);
                                //                             };
                            });
                            viz.network.selectNodes([tool].concat(UnconnectedNodes));
                            viz.network.deleteSelected();
                        }
                    });
                }
                else {
                    viz.network.unselectAll();
                    var ConnectedNodes = viz.network.getConnectedNodes(IdTool);

                    var UnconnectedNodes = [];
                    ConnectedNodes.forEach((node) => {
                        if (viz.network.getConnectedEdges(node).length == 1) {
                            UnconnectedNodes.push(node);
                        };
                    });
                    viz.network.selectNodes([e.target.value].concat(UnconnectedNodes));
                    viz.network.deleteSelected();
                }
            };
        });
    }

    var ToolTopicData = '{{tool_topic|safe}}';
    ToolTopicData = JSON.parse(ToolTopicData);
    console.log(ToolTopicData);
    console.log('{{tool_topic|tojson}}');

    $(function () {
        $("#tooltopic_autocomplete").autocomplete({
            source: ToolTopicData,
            minLength: 1,
            select: function (event, ui) {

                var name = ui.item.value;
                var id = ui.item.identificator;

                var cypher_min = $("#amount").val().substr(0, $("#amount").val().indexOf('-') - 1);
                var cypher_max = $("#amount").val().substr($("#amount").val().indexOf('-') + 2, $("#amount").val().length);

                console.log(ui.item);
                if (ui.item.labelnode == "Topic") {
                    AddTopic(name, id, cypher_min, cypher_max);

                } else {
                    AdddNode(name, id, cypher_min, cypher_max);
                }
                $(this).val('');
                return false;

            },
            html: true,
            open: function (event, ui) {
                $(".ui-autocomplete").css("z-index", 1000);

            }
        })
        .autocomplete("instance")._renderItem = function (ul, item) {
            if (item.labelnode == "InferedTool") {
                return $("<li><div><img src='../static/tool_centered_sm.png'><span>" + item.value + "</span></div></li>").appendTo(ul);
            }
            else if (item.labelnode == "Database") {
                return $("<li><div><img src='../static/database_centered_sm.png'><span>" + item.value + "</span></div></li>").appendTo(ul);

            } else {
                return $("<li><div><img src='../static/topic_centered_sm.png'><span>" + item.value + "</span></div></li>").appendTo(ul);

            }
        };
    });

</script>

<script>

    function algo(c_min, c_max) {

        viz.network.on("selectNode", (e1) => {
            console.log("selecting");
            //         viz.network.deleteNode(65086);
            console.log(e1);
            Menu(e1, c_min, c_max);
        });

        viz.network.on("deselectNode", (e1) => {
            console.log("deselect");
            var contextMenu = document.getElementById("context-menu");
            contextMenu.innerHTML = '';
        });

        viz.network.on("stabilizationProgress", (e1)=>{
            console.log(e1);
        })
    }

</script>

<script>

    function RemoveAllToolsMenu() {
        const list = document.querySelector('#tools-list ul');
        list.innerHTML = "";
    }

</script>

<script>

    function ExpandNode(NameTool, NodeID, c_min, c_max) {

        var list = document.getElementsByClassName('delete');
        var isInMenu = false;

        Array.prototype.forEach.call(list, function (tool) {
            console.log(tool);

            if (tool.textContent === NameTool) {
                console.log(NameTool);
                isInMenu = true;
            }
        });
        if (isInMenu == false) {
            console.log(isInMenu);
            AddTool(NameTool, c_min, c_max)
            AddLabelMenu(NameTool, NodeID)
        }
    }

</script>

<script>

    function AdddNode(NameTool, NodeID, c_min, c_max) {

        var list = document.getElementsByClassName('delete');
        var isInMenu = false;

        Array.prototype.forEach.call(list, function (tool) {
            console.log(tool);

            if (tool.textContent === NameTool) {
                console.log(NameTool);
                isInMenu = true;
            }
        });
        if (isInMenu == false) {
            console.log(isInMenu);
            AddTool(NameTool, c_min, c_max)
            AddLabelMenu(NameTool, NodeID)
        }
    }

</script>

<script>

    function CenterNode(name, node_id, c_min, c_max) {


        var list = document.getElementsByClassName('delete');
        var isInMenu = false;

        Array.prototype.forEach.call(list, function (tool) {
            console.log(tool);
            if (tool.textContent != name) {
                console.log(tool.parentElement);

                const li = tool.parentElement;
                li.parentNode.removeChild(li);
                var IdTool = tool.value;
                viz.network.unselectAll();
                var ConnectedNodes = viz.network.getConnectedNodes(IdTool);

                var UnconnectedNodes = [];
                ConnectedNodes.forEach((node) => {
                    if (viz.network.getConnectedEdges(node).length == 1) {
                        UnconnectedNodes.push(node);
                    };
                });
                viz.network.selectNodes([tool.value].concat(UnconnectedNodes));
                viz.network.deleteSelected();
            }
            else {
                isInMenu = true;
            }
        });
        if (isInMenu == false) {
            viz.reload();
            RemoveAllToolsMenu();
            AddTool(name, c_min, c_max)
            AddLabelMenu(name, node_id)
        }
    }

</script>

<script>

    async function AddTopicNodes(NameTopic, c_min, c_max) {

        var cypher_query = 'match (n)-[:TOPIC]->(k:Keyword)-[:SUBCLASS*]->(k2:Keyword) where k2.label="' + NameTopic + '" or k.label="' + NameTopic + '" with distinct n with collect(n) as nt unwind nt as nt1 unwind nt as nt2 match (nt1)-[m:METAOCCUR_ALL]-(nt2) return nt1,m,nt2';

        viz.updateWithCypher(cypher_query);
        console.log(cypher_query);

        await new Promise(r => setTimeout(r, 5000));
        console.log(viz.nodes.length);
        if (viz.nodes.length == 0) {
            alert("No results found. Try again!");
        }
        algo(c_min, c_max);

        await new Promise(r => {
            StoreClusterColor();
        });
    }

    function AddTopicLabelMenu(NameTopic, id) {
        const list = document.querySelector('#tools-list ul');

        // create elements
        const value = NameTopic
        const li = document.createElement('li');
        const ToolName = document.createElement('span');
        //   const deleteBtn = document.createElement('span');

        // add text content
        ToolName.textContent = value;
        //   deleteBtn.textContent = 'delete';
        // add classes
        ToolName.classList.add('delete');

        ToolName.value = id;

        // append to DOM
        li.appendChild(ToolName);
        //   li.appendChild(deleteBtn);
        list.appendChild(li);
        //list.insertBefore(li, list.querySelector('li:first-child'));

        // delete books
        list.addEventListener('click', (e) => {
            console.log("removing topic")
            if (e.target.className == 'delete') {
                const li = e.target.parentElement;
                li.parentNode.removeChild(li);
                var IdTool = e.target.value;
                console.log(IdTool);
                IdTool.forEach((tool) => {
                    console.log(tool);
                    if (viz.nodes.get(tool) != null) {
                        viz.network.unselectAll();
                        var ConnectedNodes = viz.network.getConnectedNodes(tool);

                        var UnconnectedNodes = [];
                        ConnectedNodes.forEach((node) => {
                            //                             if(viz.network.getConnectedEdges(node).length==1){
                            UnconnectedNodes.push(node);
                            //                             };
                        });
                        viz.network.selectNodes([tool].concat(UnconnectedNodes));
                        viz.network.deleteSelected();
                    }
                });
            };
        });
    }

    function AddTopic(NameTopic, id, c_min, c_max) {

        var list = document.getElementsByClassName('delete');
        var isInMenu = false;

        Array.prototype.forEach.call(list, function (tool) {
            console.log(tool);

            if (tool.textContent === NameTopic) {
                console.log(NameTopic);
                isInMenu = true;
            }
        });
        if (isInMenu == false) {
            console.log(isInMenu);
            AddTopicNodes(NameTopic, c_min, c_max);
            AddTopicLabelMenu(NameTopic, id);
        }
    }

</script>

<script>
    function Menu(e1, c_min, c_max) {
        if (e1.nodes.length === 1) {
            var node_id = e1.nodes[0];
            if (viz.network.body.nodes[node_id].options.raw.labels[0] == "Publication") {
                return;
            }
            console.log(node_id);
            console.log(viz.network.body.nodes[node_id]);

            // Display menu
            const contextMenu = document.getElementById("context-menu");
            contextMenu.innerHTML = '<div class="topicmenu" id="topic"></div><div class="item" id = "webpage"></div><div class="item" id="center"></div><div class="item" id="expand"></div>'
            const scope = document.querySelector("body");

            var name = viz.network.body.nodes[node_id].options.raw.properties.name;
            console.log(name);

            var label = viz.network.body.nodes[node_id].options.raw.properties.label;
            console.log(label);


            if ("topiclabel" in viz.network.body.nodes[node_id].options.raw.properties) {
                var topiclabel = viz.network.body.nodes[node_id].options.raw.properties.topiclabel;
                console.log(topiclabel.length);

                var topicedam = viz.network.body.nodes[node_id].options.raw.properties.topicedam;
                console.log(topicedam);

                document.getElementById("topic").innerHTML = "";
                for (var i = 0; i < topiclabel.length; i++) {
                    document.getElementById("topic").innerHTML += '<button onclick="AddTopic(&#34;' + topiclabel[i] + '&#34;, &#34;' + c_min + '&#34;, &#34;' + c_max + '&#34;)" >' + topiclabel[i] + '</button>';
                }
            }



            document.getElementById("webpage").innerHTML = '<button onclick="window.open(&#34;https://openebench.bsc.es/tool/' + label + '&#34; , &#34;_blank&#34; )">Webpage</button>';

            document.getElementById("center").innerHTML = '<button onclick="CenterNode(&#34;' + name + '&#34;, &#34;' + node_id + '&#34;, &#34;' + c_min + '&#34;, &#34;' + c_max + '&#34;)">Center</button>';

            document.getElementById("expand").innerHTML = '<button onclick="ExpandNode(&#34;' + name + '&#34;, &#34;' + node_id + '&#34;, &#34;' + c_min + '&#34;, &#34;' + c_max + '&#34;)">Expand</button>';

            const normalizePozition = (mouseX, mouseY) => {
                // ? compute what is the mouse position relative to the container element (scope)
                let {
                    left: scopeOffsetX,
                    top: scopeOffsetY,
                } = scope.getBoundingClientRect();

                scopeOffsetX = scopeOffsetX < 0 ? 0 : scopeOffsetX;
                scopeOffsetY = scopeOffsetY < 0 ? 0 : scopeOffsetY;

                const scopeX = mouseX - scopeOffsetX;
                const scopeY = mouseY - scopeOffsetY;

                // ? check if the element will go out of bounds
                const outOfBoundsOnX =
                    scopeX + contextMenu.clientWidth > scope.clientWidth;

                const outOfBoundsOnY =
                    scopeY + contextMenu.clientHeight > scope.clientHeight;

                let normalizedX = mouseX;
                let normalizedY = mouseY;

                // ? normalize on X
                if (outOfBoundsOnX) {
                    normalizedX =
                        scopeOffsetX + scope.clientWidth - contextMenu.clientWidth;
                }

                // ? normalize on Y
                if (outOfBoundsOnY) {
                    normalizedY =
                        scopeOffsetY + scope.clientHeight - contextMenu.clientHeight;
                }

                return { normalizedX, normalizedY };
            };

            scope.addEventListener("contextmenu", (event) => {
                event.preventDefault();


                const { clientX: mouseX, clientY: mouseY } = event;

                const { normalizedX, normalizedY } = normalizePozition(mouseX, mouseY);

                contextMenu.classList.remove("visible");

                contextMenu.style.top = `${normalizedY}px`;
                contextMenu.style.left = `${normalizedX}px`;




                setTimeout(() => {
                    contextMenu.classList.add("visible");
                });
            });

            scope.addEventListener("click", (e) => {
                // ? close the menu if the user clicks outside of it
                if (e.target.offsetParent != contextMenu) {
                    contextMenu.classList.remove("visible");
                }
            });
        }
    }

</script>

<script>
    function StoreClusterColor(){
        setTimeout(function() {
            var net = viz.network.body;
            var allNodes = net.nodeIndices;
            
            allNodes.forEach((node) => {
                if (net.nodes[node].options.hasOwnProperty("colorcluster")){
                    return true;
                }
                var obj_cluster ={colorcluster :{background:null, border:null, highlight:{background: null, border:null}, hover:{background: null, border:null}}};
                obj_cluster.colorcluster.background = net.nodes[node].options.color.background;
                obj_cluster.colorcluster.border = net.nodes[node].options.color.border
                obj_cluster.colorcluster.highlight.background = net.nodes[node].options.color.highlight.background
                obj_cluster.colorcluster.highlight.border = net.nodes[node].options.color.highlight.border
                obj_cluster.colorcluster.hover.background = net.nodes[node].options.color.hover.background
                obj_cluster.colorcluster.hover.border = net.nodes[node].options.color.hover.border
                
                obj_normal = {colornormal :{background:null, border:null, highlight:{background: null, border:null}, hover:{background: null, border:null}}};
                if (net.nodes[node].options.raw.labels[0]=="InferedTool"){
                    obj_normal.colornormal.background="#add8e6"
                    obj_normal.colornormal.border="#add8e6"
                    obj_normal.colornormal.highlight.background="#add8e6"
                    obj_normal.colornormal.highlight.border="#add8e6"
                    obj_normal.colornormal.hover.background="#add8e6"
                    obj_normal.colornormal.hover.border="#add8e6"
                }
                else if (net.nodes[node].options.raw.labels[0]=="Database"){
                    obj_normal.colornormal.background="#cb6d51"
                    obj_normal.colornormal.border="#cb6d51"
                    obj_normal.colornormal.highlight.background="#cb6d51"
                    obj_normal.colornormal.highlight.border="#cb6d51"
                    obj_normal.colornormal.hover.background="#cb6d51"
                    obj_normal.colornormal.hover.border="#cb6d51"
                }
                else{
                    obj_normal.colornormal.background="#ff4000"
                    obj_normal.colornormal.border="#ff4000"
                    obj_normal.colornormal.highlight.background="#ff4000"
                    obj_normal.colornormal.highlight.border="#ff4000"
                    obj_normal.colornormal.hover.background="#ff4000"
                    obj_normal.colornormal.hover.border="#ff4000"
                }
                net.nodes[node].options = Object.assign(net.nodes[node].options, obj_cluster)
                net.nodes[node].options = Object.assign(net.nodes[node].options, obj_normal)
            });
        });

    }
</script>

<script>
    function ClusterMode(){
        option_radio = document.querySelector('input[name="cluster_mode"]:checked');
        console.log(option_radio.value);
        var list_changes = [];
        if (option_radio.value == "Cluster"){
            console.log("Cluster2")
            var net = viz.network.body;
            var allNodes = net.nodeIndices;
            allNodes.forEach((node) => {
                var change_node = {
                    id:node,
                    color: {
                        background: net.nodes[node].options.colorcluster.background,
                        border: net.nodes[node].options.colorcluster.border,
                        highlight: {
                            border: net.nodes[node].options.colorcluster.highlight.border,
                            background: net.nodes[node].options.colorcluster.highlight.background
                        },
                        hover : {
                            border: net.nodes[node].options.colorcluster.hover.border,
                            background: net.nodes[node].options.colorcluster.hover.background
                        }
                    }
                };
                list_changes.push(change_node);
            });

        }
        else{
            console.log("Normal");
            var net = viz.network.body;
            var allNodes = net.nodeIndices;
            allNodes.forEach((node) => {
                var change_node = {
                    id:node,
                    color: {
                        background: net.nodes[node].options.colornormal.background,
                        border: net.nodes[node].options.colornormal.border,
                        highlight: {
                            border: net.nodes[node].options.colornormal.highlight.border,
                            background: net.nodes[node].options.colornormal.highlight.background
                        },
                        hover : {
                            border: net.nodes[node].options.colornormal.hover.border,
                            background: net.nodes[node].options.colornormal.hover.background
                        }
                    }
                };
                list_changes.push(change_node);
            });
        }
        viz.nodes.update(list_changes);
    }
</script>

<script>
    function AddLoadingTool (){ 
            console.log("Holita")
            setTimeout(function () {
                ClusterMode();

            })
            var loadingid = document.querySelector('.loadingbar');
            console.log(loadingid);
            viz.stabilize();


            // loadingid.parentElement.removeChild(loadingid);
            viz.network.off('afterDrawing', AddLoadingTool);
            viz.network.fit();
            loadingid.parentNode.removeChild(loadingid);

        };

    function WaitAddTool(){
        setTimeout(function(){
            console.log("Holi");
            viz.network.on('afterDrawing', AddLoadingTool);

        })
    }
</script>

<script>

    const res = document.getElementById("reset");

    // Reset All Neo4j
    res.addEventListener('click', (e) => {
        viz.reload();
        RemoveAllToolsMenu();

    });

</script>

<script>

    const sta = document.getElementById("stabilize");

    // Stabilize the network
    sta.addEventListener('click', (e) => {
        viz.stabilize();
    });

</script>

</html>